<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | George's dream port]]></title>
  <link href="http://puffsun.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://puffsun.github.io/"/>
  <updated>2014-04-07T07:22:55+08:00</updated>
  <id>http://puffsun.github.io/</id>
  <author>
    <name><![CDATA[George Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Singleton Pattern in Java]]></title>
    <link href="http://puffsun.github.io/blog/2014/04/07/singleton-pattern-in-java/"/>
    <updated>2014-04-07T06:54:11+08:00</updated>
    <id>http://puffsun.github.io/blog/2014/04/07/singleton-pattern-in-java</id>
    <content type="html"><![CDATA[<p>The Singleton pattern is deceptively simple, even and especially for Java developers, but it presents a number of pitfalls for the unwary Java developer which make it hard to implement properly. In this article, I&rsquo;ll talk about several ways to implement the Singleton pattern in Java, and leave it to you to decide which one is best suited for your circumstance depending on your requirement.</p>

<!--more-->


<p>With the Singleton design pattern you can:</p>

<ul>
<li>Ensure that only one instance of a class is created</li>
<li>Provide a global point of access to the object</li>
<li>Allow multiple instances in the future without affecting a singleton class&rsquo;s clients</li>
</ul>


<h3>The classic Singleton pattern<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></h3>

<p>In Design Patterns: <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Elements of Reusable Object-Oriented Software</a>, the GoF describe the Singleton pattern like this:</p>

<blockquote><p>Ensure a class has only one instance, and provide a global point of access to it.</p></blockquote>

<p>```java
public class ClassicSingleton {</p>

<pre><code>private static ClassicSingleton instance = null;

private ClassicSingleton() {
    // Exists only to defeat instantiation.
}

public static ClassicSingleton getInstance() {
    if (instance == null) {
        instance = new ClassicSingleton();
    }
    return instance;
}
</code></pre>

<p>}
```</p>

<p>Above code is easy to understand, the ClassicSingleton hold a static reference to the single instance and returns that reference from the static <code>getInstance()</code> method.</p>

<p>There are several interesting points concerning the ClassicSingleton class.
1. ClassicSingleton employs a technique known as lazy instantiation to create the singleton; as a result, the singleton instance is not created until the <code>getInstance()</code> method is called for the first time. This technique ensures that singleton instances are created only when needed.
2. It&rsquo;s possible to have multiple singleton instances if classes loaded by different Classloaders access a singleton. That scenario is not so far-fetched; for example, some servlet containers use distinct Classloaders for each servlet, so if two servlets access a singleton, they will each have their own instance.
3. If ClassicSingleton implements the <code>java.io.Serializable</code> interface, the class&rsquo;s instances can be serialized and deserialized. However, if you serialize a singleton object and subsequently deserialize that object more than once, you will have multiple singleton instances.
4. ClassicSingleton class is not thread-safe. If two threads—we&rsquo;ll call them Thread 1 and Thread 2—call <code>ClassicSingleton.getInstance()</code> at the same time, two ClassicSingleton instances can be created if Thread 1 is preempted just after it enters the if block and control is subsequently given to Thread 2.
5. A privileged client can invoke the private constructor reflectively with the aid of the <code>AccessibleObject.setAccessible</code> method. If you need to defend against this attack, modify the constructor to make it throw an exception if it’s asked to create a second instance.</p>

<p>As you can see from the preceding discussion, although the Singleton pattern is one of the simplest design patterns, implementing it in Java is anything but simple. The rest of this article addresses Java-specific considerations for the Singleton pattern.</p>

<h3>Synchronization for multithreading considerations</h3>

<p>Making Singleton thread-safe is easy-just synchronize the <code>getInstance()</code> method:
```java
public class Singleton {</p>

<pre><code>private static Singleton instance = null;

private Singleton() {
    // Exists only to defeat instantiation.
}

public synchronized static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
</code></pre>

<p>}
```
However, the astute reader may realize that the getInstance() method only needs to be synchronized the first time it is called. Because synchronization is very expensive performance-wise, perhaps we can introduce a performance enhancement that only synchronizes the singleton assignment in <code>getInstance()</code>.</p>

<h3>A performance enhancement</h3>

<p>In search of a performance enhancement, you might choose to rewrite the <code>getInstance()</code> method like this:
```java
// CAUTION, BUGS AHEAD
public static Singleton getInstance() {
   if(singleton == null) {</p>

<pre><code>  synchronized(Singleton.class) { 
     singleton = new Singleton();
  }
</code></pre>

<p>   }
   return singleton;
}
```
Instead of synchronizing the entire method, the preceding code fragment only synchronizes the critical code. However, the preceding code fragment is not thread-safe. Consider the following scenario: Thread 1 enters the synchronized block, and, before it can assign the singleton member variable, the thread is preempted. Subsequently, another thread can enter the if block. The second thread will wait for the first thread to finish, but we will still wind up with two distinct singleton instances. Is there a way to fix this problem? Read on.</p>

<h3>Double-checked locking</h3>

<p>Double-checked locking is a technique that, at first glance, appears to make lazy instantiation thread-safe. That technique is illustrated in the following code fragment:
```java
// CAUTION, BUGS AHEAD
public static Singleton getInstance() {
  if(singleton == null) {</p>

<pre><code> synchronized(Singleton.class) {
   if(singleton == null) {
     singleton = new Singleton();
   }
}
</code></pre>

<p>  }
  return singleton;
}
```
What happens if two threads simultaneously access <code>getInstance()</code>? Imagine Thread 1 enters the synchronized block and is preempted. Subsequently, a second thread enters the if block. When Thread 1 exits the synchronized block, Thread 2 makes a second check to see if the singleton instance is still null. Since Thread 1 set the singleton member variable, Thread 2&rsquo;s second check will fail, and a second singleton will not be created. Or so it seems.</p>

<p>Unfortunately, double-checked locking is not guaranteed to work because the compiler is free to assign a value to the singleton member variable before the singleton&rsquo;s constructor is called. If that happens, Thread 1 can be preempted after the singleton reference has been assigned, but before the singleton is initialized, so Thread 2 can return a reference to an uninitialized singleton instance.</p>

<p>Since double-checked locking is not guaranteed to work, you must synchronize the entire getInstance() method. However, another alternative is simple, fast, and thread-safe.</p>

<h3>An alternative thread-safe singleton implementation</h3>

<p>```java
public class Singleton {
   public final static Singleton INSTANCE = new Singleton();
   private Singleton() {</p>

<pre><code>   // Exists only to defeat instantiation.
</code></pre>

<p>   }
}
```
The preceding singleton implementation is thread-safe because static member variables created when declared are guaranteed to be created the first time they are accessed. You get a thread-safe implementation that automatically employs lazy instantiation, until the class file get loaded into memory, their is no instance instanciated at all.</p>

<p>Of course, like nearly everything else, the preceding singleton is a compromise; if you use that implementation, you can&rsquo;t change your mind and allow multiple singleton instances later on. With a more conservative singleton implementation, instances are obtained through a <code>getInstance()</code> method, and you can change those methods to return a unique instance or one of hundreds. You can&rsquo;t do the same with a public static member variable.
```java
public class Singleton {
   private final static Singleton INSTANCE = new Singleton();
   private Singleton() {</p>

<pre><code>   // Exists only to defeat instantiation.
</code></pre>

<p>   }</p>

<p>   public static Singleton getInstance() {</p>

<pre><code>   return INSTANCE;
</code></pre>

<p>   }
}
```</p>

<h3>Leveraging volatile to change Java Memory Model</h3>

<p>We can recheck the instance again in synchronized block to ensure that only one instance of the Singleton object be instantiated, shown as below code:
```java
public class LazySingleton {</p>

<pre><code>private static volatile LazySingleton instance;

// private constructor
private LazySingleton() {
}

public static LazySingleton getInstance() {
    if (instance == null) {
        synchronized (LazySingleton.class) {
            // Double check
            if (instance == null) {
                instance = new LazySingleton();
            }
        }
    }
    return instance;
}
</code></pre>

<p>}
```
Please ensure to use <code>volatile</code> keyword with instance variable otherwise you can run into out of order write error scenario, where reference of instance is returned before actually the object is constructed i.e. JVM has only allocated the memory and constructor code is still not executed. In this case, your other thread, which refer to uninitialized object may throw null pointer exception and can even crash the whole application.</p>

<p>Although above code is the correct way to implement Singleton pattern, this is not recommended since it introduce extra complexity of code, which may introduce subtle bugs.</p>

<h3>Classloaders</h3>

<p>Because multiple classloaders are commonly used in many situations—including servlet containers—you can wind up with multiple singleton instances no matter how carefully you&rsquo;ve implemented your singleton classes. If you want to make sure the same classloader loads your singletons, you must specify the classloader yourself; for example:
```java
private static Class getClass(String classname) throws ClassNotFoundException {</p>

<pre><code>ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
if(classLoader == null)
    classLoader = Singleton.class.getClassLoader();
    return (classLoader.loadClass(classname));
}
</code></pre>

<p>}
```
The preceding method tries to associate the classloader with the current thread; if that classloader is null, the method uses the same classloader that loaded a singleton base class. The preceding method can be used instead of Class.forName().</p>

<h3>Serialization<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3>

<p>If you serialize a singleton and then deserialize it twice, you will have two instances of your singleton, unless you implement the <code>readResolve()</code> method, like this:
```java
public class Singleton implements java.io.Serializable {</p>

<pre><code>private static final long serialVersionUID = 1L;
public static Singleton INSTANCE = new Singleton();

private Singleton() {
    // Exists only to thwart instantiation.
}

private Object readResolve() {
    return INSTANCE;
}
</code></pre>

<p>}
```
The previous singleton implementation returns the lone singleton instance from the readResolve() method; therefore, whenever the Singleton class is deserialized, it will return the same singleton instance. <strong>Don&rsquo;t forget to add serial version id in this case, or you will get an exception during de-serialise process</strong>.</p>

<h3>Bill Pugh solution<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup></h3>

<p>Bill Pugh was main force behind java memory model changes. His principle “Initialization-on-demand holder idiom” also uses static block but in different way. It suggest to use static inner class:
```java
public class BillPughSingleton {</p>

<pre><code>private BillPughSingleton() {
}

private static class LazyHolder {
    private static final BillPughSingleton INSTANCE = new BillPughSingleton();
}

public static BillPughSingleton getInstance() {
    return LazyHolder.INSTANCE;
}
</code></pre>

<p>}
```
As you can see, until we need an instance, the LazyHolder class will not be initialized until required and you can still use other static members of BillPughSingleton class. This is the solution, i will recommend to use. I also use it in my all projects.</p>

<h3>Using Enum</h3>

<p>As of release 1.5, there is a another approach to implementing singletons. which provide implicit support for thread safety and only one instance is guaranteed. This is also a good way to have singleton with minimum effort. Simply make an enum type with one element:
```java
// Enum singleton &ndash; the preferred approach
public enum Elvis {</p>

<pre><code>INSTANCE;
public void leaveTheBuilding() { ... }
</code></pre>

<p>}
```
This approach is functionally equivalent to the public field approach, except that it is more concise, provides the serialization machinery for free, and provides an ironclad guarantee against multiple instantiation, even in the face of sophisticated serialization or reflection attacks. While this approach has yet to be widely adopted, <strong>a single-element enum type is the best way to implement a singleton</strong>.</p>

<h3>Preventing privileged clients</h3>

<p>As we mentioned before, single pattern can be broken with reflection, as below code shown:
```java
public static void main(String[] args) throws Exception {</p>

<pre><code>Singleton s1 = Singleton.getInstance();
Class clazz = Singleton.class;
Constructor cons = clazz.getDeclaredConstructor();
cons.setAccessible(true);
// Another instance can be instantiated now.
Singleton s2 = (Singleton) cons.newInstance();
</code></pre>

<p>}
<code>
It's easy to get over this issue:
</code>java
public class PrivilegedSingleton {</p>

<pre><code>private static final PrivilegedSingleton INSTANCE = new PrivilegedSingleton();

private PrivilegedSingleton() {

    // Check if we already have an instance
    if (INSTANCE != null) {
        throw new IllegalStateException("Singleton instance already created.");
    }
}

public static PrivilegedSingleton getInstance() {
    return INSTANCE;
}
</code></pre>

<p>}
```
Sometimes, your IDE may remind you that the <code>INSTANCE</code> variable will never be null, don&rsquo;t rely on that, IDE can make mistake too.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.javaworld.com/article/2073352/core-java/simply-singleton.html">Simply Singleton: Navigate the deceptively simple Singleton pattern</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683">Effective Java, 2nd edition</a><a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p><a href="http://howtodoinjava.com/2012/10/22/singleton-design-pattern-in-java/">Singleton design pattern in Java</a><a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Service Provider Frameworks]]></title>
    <link href="http://puffsun.github.io/blog/2014/04/06/service-provider-frameworks-pattern/"/>
    <updated>2014-04-06T22:39:44+08:00</updated>
    <id>http://puffsun.github.io/blog/2014/04/06/service-provider-frameworks-pattern</id>
    <content type="html"><![CDATA[<h3>Overview</h3>

<p>In <a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683">Effective Java, second edition</a>, the author mentioned a pattern called Service Provider frameworks. The author wrote:</p>

<blockquote><p>A service provider framework is a system in which multiple service providers implement a service, and the system makes the implementations available to its clients, decoupling them from the implementations.</p></blockquote>

<p>In this blog post, I&rsquo;ll talk about the details of Service Provider Frameworks thru it&rsquo;s application in JDK, to be specific, in JDBC and Codec lookup.</p>

<!--more-->


<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>As the author said, there are three essential components of a service provider framework: a <strong>service interface</strong>, which providers implement; a <strong>provider registration API</strong>, which the system uses to register implementations, giving clients access to them; and a <strong>service access API</strong>, which clients use to obtain an instance of the service. The service access API typically allows but does not require the client to specify some criteria for choosing a provider. In the absence of such a specification, the API returns an instance of a default implementation. The service access API is the “flexible static factory” that forms the basis of the service provider framework.</p>

<p>An optional fourth component of a service provider framework is a <strong>service provider interface</strong>, which providers implement to create instances of their service implementation. <em>In the absence of a service provider interface, implementations are registered by class name and instantiated reflectively</em>.</p>

<h3>Service Provider Frameworks in JDBC</h3>

<p>In the case of <a href="http://www.oracle.com/technetwork/java/javase/jdbc/index.html">JDBC</a>, <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/Connection.html">Connection</a> plays the part of the service interface, <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html#registerDriver(java.sql.Driver)">DriverManager.registerDriver</a> is the provider registration API, <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html#getConnection(java.lang.String)">DriverManager.getConnection</a> is the service access API, and <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/Driver.html">Driver</a> is the service provider interface.</p>

<p>Usually in order to use JDBC, you should execute below code:
```java</p>

<pre><code>  // Register JDBC driver, before JDBC 4.0 only
  Class.forName("com.mysql.jdbc.Driver");

  // Open a connection
  System.out.println("Connecting to database...");
  conn = DriverManager.getConnection(DB_URL,USER,PASS);
</code></pre>

<p>```
The <code>Class.forname(&ldquo;com.mysql.jdbc.Driver&rdquo;)</code> can be eliminated after JDBC 4.0, as you can see in the document of <a href="http://docs.oracle.com/javase/7/docs/api/java/sql/DriverManager.html">DriverManager</a></p>

<blockquote><p>The DriverManager methods getConnection and getDrivers have been enhanced to support the Java Standard Edition <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider">Service Provider</a> mechanism. JDBC 4.0 Drivers must include the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC drivers implementation of java.sql.Driver. For example, to load the my.sql.Driver class, the META-INF/services/java.sql.Driver file would contain the entry:
my.sql.Driver
Applications no longer need to explicitly load JDBC drivers using <code>Class.forName()</code>. Existing programs which currently load JDBC drivers using Class.forName() will continue to work without modification.</p></blockquote>

<h3>Service Provider mechanism<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></h3>

<p>Now let&rsquo;s dig deeper into the <strong>Service Provider mechanism</strong> and <strong>Service Provider configuration file</strong>, you can find it <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider">here</a>:</p>

<p>Files in the <code>META-INF/services</code> directory are service provider configuration files. A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers may be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers may also be made available by adding them to the applet or application class path or by some other platform-specific means.</p>

<p>A service is represented by an abstract class. A provider of a given service contains one or more concrete classes that extend this service class with data and code specific to the provider. This provider class will typically not be the entire provider itself but rather a proxy that contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such class has been defined. The only requirement enforced here is that provider classes must have a zero-argument constructor so that they may be instantiated during lookup.</p>

<h3>Provider-Configuration File</h3>

<p>A service provider identifies itself by placing a provider-configuration file in the resource directory <code>META-INF/services</code>. The file&rsquo;s name should consist of the fully-qualified name of the abstract service class. The file should contain a newline-separated list of unique concrete provider-class names. Space and tab characters, as well as blank lines, are ignored. The comment character is &lsquo;#&rsquo; (0x23); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.</p>

<h3>Example of Service Provider mechanism</h3>

<p>Suppose we have a service class named <code>java.io.spi.CharCodec</code>. It has two abstract methods:
<code>java
public abstract CharEncoder getEncoder(String encodingName);
public abstract CharDecoder getDecoder(String encodingName);
</code>
Each method returns an appropriate object or null if it cannot translate the given encoding. Typical CharCodec providers will support more than one encoding.</p>

<p>If <code>sun.io.StandardCodec</code> is a provider of the <code>CharCodec</code> service then its jar file would contain the file <code>META-INF/services/java.io.spi.CharCodec</code>. This file would contain the single line:
<code>sun.io.StandardCodec    # Standard codecs for the platform</code>
To locate an encoder for a given encoding name, the internal I/O code would do something like this:
```java
   CharEncoder getEncoder(String encodingName) {</p>

<pre><code>   Iterator ps = Service.providers(CharCodec.class);
   while (ps.hasNext()) {
       CharCodec cc = (CharCodec)ps.next();
       CharEncoder ce = cc.getEncoder(encodingName);
       if (ce != null)
           return ce;
   }
   return null;
</code></pre>

<p>   }
```
The provider-lookup mechanism always executes in the security context of the caller. Trusted system code should typically invoke the methods in this class from within a privileged security context.</p>

<h3>How Service Provider mechanism works in JDBC</h3>

<p>Now we can draw the conclusion that with service provider configuration file, during jar loading, the loading thread will find the configuration first, then register the services by name from the configuration file. The service configuration file contains the name of the JDBC driver&rsquo;s implementation of <code>java.sql.Driver</code>. For example, to load the JDBC driver to connect to a Apache Derby database, the <code>META-INF/services/java.sql.Driver</code> file would contain the following entry:
<code>org.apache.derby.jdbc.EmbeddedDriver</code>. Then it will call <code>DriverManager.registerDriver</code> to register specific Database driver automatically, so you don&rsquo;t need to call <code>Class.forName()</code> yourself. After that, you can access the service thru <strong>Service Access Interface</strong>, <code>java.sql.DriverManager.getConnection</code> to get the service, which in this case, is a implementation of <code>java.sql.Connection</code>.</p>

<p>However, before JDBC 4.0, you don&rsquo;t have the facility, you have to register database driver manually by calling <code>Class.forName</code> to register the driver before accessing the service interface.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="http://www.amazon.com/Effective-Java-Edition-Joshua-Bloch/dp/0321356683">Effective Java, second edition</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Service%20Provider">jar file specification#Service Provider</a> <a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Enum, EnumSet, and EnumMap Sample]]></title>
    <link href="http://puffsun.github.io/blog/2014/04/06/enum-enumset-enummap-sample/"/>
    <updated>2014-04-06T20:50:38+08:00</updated>
    <id>http://puffsun.github.io/blog/2014/04/06/enum-enumset-enummap-sample</id>
    <content type="html"><![CDATA[<p><a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">Enum</a> was introduced in Java 1.5, although the Java enum can be used with any Java collection, its full power is best leveraged when used with the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a>.</p>

<p>Why should you use <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a>, rather than their counterparts <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html">HashMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html">HashSet</a>. The primary reason boil down to performance and memory usage advantage. Let&rsquo;s see their JavaDoc firstly.</p>

<!-- more -->


<p>Document of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a>:</p>

<blockquote><p>A specialized Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient.
&hellip;
Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be faster than their HashMap counterparts.</p></blockquote>

<p>Document of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a>:</p>

<blockquote><p>A specialized Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors. This representation is extremely compact and efficient. The space and time performance of this class should be good enough to allow its use as a high-quality, typesafe alternative to traditional int-based &ldquo;bit flags.&rdquo; Even bulk operations (such as containsAll and retainAll) should run very quickly if their argument is also an enum set.
&hellip;
Implementation note: All basic operations execute in constant time. They are likely (though not guaranteed) to be much faster than their HashSet counterparts. Even bulk operations execute in constant time if their argument is also an enum set.</p></blockquote>

<p>Both of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a> belong to <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html">Java Collections Framework</a>, so they&rsquo;re easy to use because as Java developer, you should familiar with <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/collections/index.html">Java Collections Framework</a>; in the mean time, they&rsquo;re compact and efficient,  they&rsquo;re also enum-powered collections which are easy to use, you can see that in below sample code.</p>

<p>First, let&rsquo;s see an enum deifiniation:
```java
import java.util.EnumSet;</p>

<p>public enum Weekday {</p>

<pre><code>MONDAY {
    @Override
    public String getDetail() {
        return "Monday";
    }
},

TUESDAY {
    @Override
    public String getDetail() {
        return "Tuesday";
    }
},

WEDNESDAY {
    @Override
    public String getDetail() {
        return "Wednesday";
    }
},

THURSDAY {
    @Override
    public String getDetail() {
        return "Thursday";
    }
},

FRIDAY {
    @Override
    public String getDetail() {
        return "Friday";
    }
},

SATURDAY {
    @Override
    public String getDetail() {
        return "Saturday";
    }
},

SUNDAY {
    @Override
    public String getDetail() {
        return "Sunday";
    }
};

public abstract String getDetail();

public static final EnumSet&lt;Weekday&gt; WORKDAYS = EnumSet.range(MONDAY, FRIDAY);

public final boolean isWorkday() {
    return WORKDAYS.contains(this);
}

public static final EnumSet&lt;Weekday&gt; THE_WHOLE_WEEK = EnumSet.allOf(Weekday.class);
</code></pre>

<p>}
```
You can see that one of interesting feature of Java enum is that you can declare <strong>abstract methods</strong>, in above example getDetail() is the abstract method and all the enum fields have implemented it. You can check some other details of Java enum <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html">here</a>.</p>

<p>Let&rsquo;s move on to our sample code of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a>.</p>

<p>```java
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.Map;</p>

<p>public final class EnumSetExample {</p>

<pre><code>public static void main(String... args) {
    System.out.println("Work Schedule:");

    for (Weekday weekday : Weekday.THE_WHOLE_WEEK) {
        String action = weekday.isWorkday()
                ? "have to work"
                : "can relax";
        // Enum.ordinal starts with 0
        System.out.println(String.format("%d. On %s you " + action + ".", weekday.ordinal() + 1, weekday));
    }

    System.out.println("Do I have to work the whole week?");

    String result = Weekday.WORKDAYS.containsAll(Weekday.THE_WHOLE_WEEK)
            ? "Yes, unfortunately."
            : "Certainly not.";
    System.out.println(result);

    final EnumSet&lt;Weekday&gt; weekend = Weekday.THE_WHOLE_WEEK.clone();
    weekend.removeAll(Weekday.WORKDAYS);

    System.out.println(String.format("The weekend is %d days long.", weekend.size()));

    // EnumMap example
    EnumMap&lt;Weekday, String&gt; eMap = new EnumMap&lt;&gt;(Weekday.class);
    for (Weekday day : Weekday.THE_WHOLE_WEEK) {
        eMap.put(day, day.getDetail());
    }

    System.out.println("Print weekdays:");
    for (Map.Entry&lt;Weekday, String&gt; entry : eMap.entrySet()) {
        System.out.println(entry.getKey() + "\t" + entry.getValue());
    }
}
</code></pre>

<p>}
```
You can run above source code by yourself, check the result then find related API of <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html">EnumMap</a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">EnumSet</a>. The above source code makes use of the following features in Java.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<ul>
<li>enum keyword</li>
<li>enum custom methods</li>
<li>enum toString() method</li>
<li>EnumSet#range()</li>
<li>EnumSet#allOf()</li>
<li>EnumSet#clone()</li>
<li>EnumSet#removeAll()</li>
<li>EnumSet#size()</li>
<li>EnumSet iteration</li>
<li>String#format()</li>
<li>EnumMap construction and iteration</li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p><a href="https://weblogs.java.net/blog/mkarg/archive/2010/01/03/fun-enumset">Fun with EnumSet</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
